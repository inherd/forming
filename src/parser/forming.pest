alpha = { 'a'..'z' | 'A'..'Z' }
digit = { '0'..'9' }

start = _{ SOI ~ declaration* ~ EOI}

declaration = {
    arch_decl
  | struct_for_decl
  | concept_decl
  | concepts_decl
  | contract_decl
  | api_root_decl
}

layered_declaration = {
    "layered" | "分层"
}

arch_decl = {
    "architecture" | "arch" | "架构"
}

component_declaration = {
    "component" | "comp" | "组件"
}

struct_for_decl = {
    "struct" ~ "for" ~ identifier ~ "{" ~ struct_body? ~ "}"
}

concept_decl = {
    "concept" ~ (identifier | string_literal) ~ "{" ~ comments? ~ ( inline_struct_declaration | behavior_declaration)* ~ "}"
}

inline_struct_declaration = {
    "struct" ~ "{" ~ struct_body? ~ "}"
    | "struct" ~ "uml" ~ "::" ~ source ~ "." ~ "class" ~ "(" ~ string_literal ~ ")"
}

struct_node = {
    identifier ~ ("," ~ identifier)? ~ ":" ~ struct_type
}

struct_body = {
    struct_node ~ ("," ~ struct_node)*
}

struct_type = {
    identifier
}

behavior_declaration = {
    "behavior" ~ "{" ~ "}"
}

contract_decl = {
    contract_ident_decl
    | contract_class_decl
}

api_root_decl = {
   "api" ~ "for" ~ api_ident ~ "{" ~ api_body? ~ "}"
}

api_body = {
    "import" ~ string_literal
     | api_decl*
}

api_decl = {
    api_in_decl
    | api_out_decl
    | pre_cond
    | post_cond
}

api_in_decl = {
    "in" ~ "{" ~ struct_body ~ "}"
}

api_out_decl = {
    "out" ~ "{" ~ struct_body ~ "}"
}

api_ident = {
   ('a'..'z' | 'A'..'Z' | "_" | "-" | "/" | ":" | "@" | "#" | "?" | "%" | "=" | "&" | "~" | ".") ~
    api_chars*
}

api_chars = _{'a'..'z' | 'A'..'Z' | "_" | "-" | "/" | ":" | "@" | "#" | "?" | "%" | "=" | "&" | "~"| "." | '0'..'9'}

contract_ident_decl = {
  "contract" ~ "for" ~ (identifier | string_literal) ~ "{" ~ pre_cond? ~ during? ~ post_cond? ~ "}"
}

during = {
  "during"
}

pre_cond = {
  pre_cond_text ~ "{" ~ cond_text ~ ":"  ~ cond_expr ~ "}"
}

pre_cond_text = {
  "precondition" | "pre_cond" | "precond"
}

post_cond = {
  "post_cond_text" ~ "{" ~ cond_text ~ ":"  ~ cond_expr ~ "}"
}

post_cond_text = {
  "postcondition" | "post_cond" | "precond"
}

cond_text = {
    string_literal | identifier
}

// todo: support for normal expr
cond_expr = {
    unary_operator ~ identifier
    | string_literal
}

contract_class_decl = {
  "contract" ~ "for" ~ contract_class ~ "{" ~ "}"
}

contract_class = {
  identifier ~ ("(" ~ extends ~ ")")?
}

extends = {
    identifier ~ ("," ~ identifier)*
}

source = { file | dir }

file = {
   "file" ~ "(" ~ string_literal ~ ")"
}

dir = {
   "dir" ~ "(" ~ string_literal ~ ")"
}

concepts_decl = {
    "concepts" ~ "=" ~ ">" ~ ("file" | "dir") ~ "(" ~ string_literal ~ ")"
}

// semantics condition
// extension

// arithmetic
exponent                    =  { "**" }
multiply                    =  { "*" }
divide                      =  { "/" }
modulus                     =  { "%" }
plus                        =  { "+" }
minus                       =  { "-" }

// bit
bit_shl                     =  { "<<" }
bit_shr                     =  { ">>" }
bit_and                     =  { "&" }
bit_or                      =  { "|" }
bit_xor                     =  { "^" }
bit_not                     =  { "~" }

// todo: thinking in more assign
assign                      =  { "=" }

// comparison
equal                       =  { "==" }
less                        =  { "<" }
less_equal                  =  { "<=" }
greater                     =  { ">" }
greater_equal               =  { ">=" }
not_equal                   =  { "!=" }

and                         =  { "and" | "&&" }
or                          =  { "or" | "||" }
not                         =  { "not" | "!" }

bool                        =  { bool_true | bool_false }
bool_true                   =  { "true" }
bool_false                  =  { "false" }

unary_operator              = _{ not }

string_literal = @{
    double_quoted_string |
    single_quoted_string
}

double_quoted_string  = @{ "\"" ~ (!("\"") ~ ANY)* ~ "\""}
single_quoted_string  = @{ "\'" ~ (!("\'") ~ ANY)* ~ "\'"}

identifier = @{
    ('a'..'z' | 'A'..'Z' | "_") ~
    all_chars*
}
all_chars = _{'a'..'z' | 'A'..'Z' | "_" | '0'..'9'}

newline    = _{ "\n" | "\r\n" }
WHITESPACE = _{ " " | "\t" | NEWLINE }
block_comment = _{ "/*" ~ (block_comment | !"*/" ~ ANY)* ~ "*/" }
comments = { COMMENT* }
COMMENT    = {  block_comment | (("//" | "--") ~ (!NEWLINE ~ ANY)*) }
